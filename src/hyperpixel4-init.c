#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <sys/time.h>
#include <time.h>
#include "hyperpixel4-init.h"

extern void gpioSetMode(unsigned gpio, unsigned mode);
extern void gpioSetPullUpDown(unsigned gpio, unsigned pud);
extern int gpioRead(unsigned gpio);
extern void gpioWrite(unsigned gpio, unsigned level);
extern uint32_t gpioTick(void);
extern int gpioInitialise(void);
void delayMicroseconds(unsigned int delay);
void delayMillis (unsigned int delay);

#define CLK 27 // BCM 27
#define MOSI 26 // BCM 26
#define CS 18 // BCM 18
#define DELAY 100 // clock pulse time in microseconds
#define WAIT 120 // wait time milliseconds
#define HIGH 1
#define LOW 0

int32_t commands[] = {
    0x0ff, 0x1ff, 0x198, 0x106, 0x104, 0x101, 0x008, 0x110,
    0x021, 0x109, 0x030, 0x102, 0x031, 0x100, 0x040, 0x110,
    0x041, 0x155, 0x042, 0x102, 0x043, 0x109, 0x044, 0x107,
    0x050, 0x178, 0x051, 0x178, 0x052, 0x100, 0x053, 0x16d,
    0x060, 0x107, 0x061, 0x100, 0x062, 0x108, 0x063, 0x100,
    0x0a0, 0x100, 0x0a1, 0x107, 0x0a2, 0x10c, 0x0a3, 0x10b,
    0x0a4, 0x103, 0x0a5, 0x107, 0x0a6, 0x106, 0x0a7, 0x104,
    0x0a8, 0x108, 0x0a9, 0x10c, 0x0aa, 0x113, 0x0ab, 0x106,
    0x0ac, 0x10d, 0x0ad, 0x119, 0x0ae, 0x110, 0x0af, 0x100,
    0x0c0, 0x100, 0x0c1, 0x107, 0x0c2, 0x10c, 0x0c3, 0x10b,
    0x0c4, 0x103, 0x0c5, 0x107, 0x0c6, 0x107, 0x0c7, 0x104,
    0x0c8, 0x108, 0x0c9, 0x10c, 0x0ca, 0x113, 0x0cb, 0x106,
    0x0cc, 0x10d, 0x0cd, 0x118, 0x0ce, 0x110, 0x0cf, 0x100,
    0x0ff, 0x1ff, 0x198, 0x106, 0x104, 0x106, 0x000, 0x120,
    0x001, 0x10a, 0x002, 0x100, 0x003, 0x100, 0x004, 0x101,
    0x005, 0x101, 0x006, 0x198, 0x007, 0x106, 0x008, 0x101,
    0x009, 0x180, 0x00a, 0x100, 0x00b, 0x100, 0x00c, 0x101,
    0x00d, 0x101, 0x00e, 0x100, 0x00f, 0x100, 0x010, 0x1f0,
    0x011, 0x1f4, 0x012, 0x101, 0x013, 0x100, 0x014, 0x100,
    0x015, 0x1c0, 0x016, 0x108, 0x017, 0x100, 0x018, 0x100,
    0x019, 0x100, 0x01a, 0x100, 0x01b, 0x100, 0x01c, 0x100,
    0x01d, 0x100, 0x020, 0x101, 0x021, 0x123, 0x022, 0x145,
    0x023, 0x167, 0x024, 0x101, 0x025, 0x123, 0x026, 0x145,
    0x027, 0x167, 0x030, 0x111, 0x031, 0x111, 0x032, 0x100,
    0x033, 0x1ee, 0x034, 0x1ff, 0x035, 0x1bb, 0x036, 0x1aa,
    0x037, 0x1dd, 0x038, 0x1cc, 0x039, 0x166, 0x03a, 0x177,
    0x03b, 0x122, 0x03c, 0x122, 0x03d, 0x122, 0x03e, 0x122,
    0x03f, 0x122, 0x040, 0x122, 0x052, 0x110, 0x053, 0x110,
    0x0ff, 0x1ff, 0x198, 0x106, 0x104, 0x107, 0x018, 0x11d,
    0x017, 0x122, 0x002, 0x177, 0x026, 0x1b2, 0x0e1, 0x179,
    0x0ff, 0x1ff, 0x198, 0x106, 0x104, 0x100, 0x03a, 0x160,
    0x035, 0x100, 0x011, 0x100,    -1, 0x029, 0x100,    -1
};

void setup_pins(void)
{
    gpioSetMode(CLK, PI_OUTPUT);
    gpioSetMode(MOSI, PI_OUTPUT);
    gpioSetMode(CS, PI_OUTPUT);
    gpioWrite(CS, HIGH);
}


void cleanup_pins(void)
{
    // Return the touch interrupt pin to a usable state
    gpioSetMode(CLK, PI_INPUT);
    gpioSetPullUpDown(CLK, PI_PUD_OFF);
}

void send_bits(uint16_t data, uint16_t count){
    int x;
    int mask = 1 << (count-1);
    for(x = 0; x < count; x++){
        gpioWrite(MOSI, (data & mask) > 0);
        data <<= 1;

        gpioWrite(CLK, LOW);
        delayMicroseconds(DELAY);
        gpioWrite(CLK, HIGH);
        delayMicroseconds(DELAY);
    }
    gpioWrite(MOSI, LOW);
}

void writecmd(uint16_t command){
    gpioWrite(CS, LOW);
    send_bits(command, 9);
    gpioWrite(CS, HIGH);
}

void setup_lcd(void){
    int count = sizeof(commands) / sizeof(int32_t);
    int x;
    for(x = 0; x < count; x++){
        int32_t command = commands[x];
        if(command == -1){
            delayMillis(WAIT);
            continue;
        }
        writecmd((uint16_t)command);
    }
}

int main(int argc, char **argv)
{
    if (gpioInitialise() != 0)
      return 1;

    setup_pins();
    printf("Setting up LCD:\n");
    setup_lcd();

    cleanup_pins();
    return 0;
}

// Takes a delay in microseconds
void delayMicroseconds (unsigned int delay){
	struct timeval now, pulse;
	int micros;

	gettimeofday(&pulse, NULL);
	micros = 0;
	while (micros < delay ){
		gettimeofday(&now, NULL);
		if (now.tv_sec > pulse.tv_sec) micros = 1000000L; else micros = 0;
		micros = micros + (now.tv_usec - pulse.tv_usec);
	}
}

void delayMillis (unsigned int delay){
	struct timespec longwait, rem;
	longwait.tv_sec = (time_t)(delay / 1000);
	longwait.tv_nsec = (long)((delay % 1000) * 1000000);
	nanosleep(&longwait, &rem);
}
